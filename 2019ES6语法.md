## ES6

### 1.let&const&var

let声明关键字，{}，具有块级作用域；

let没有变量提升；

let暂时性死区；for里面，i

const声明变量，内存地址不能修改；

### 2.解构赋值

数组的解构：一一对应

let [a,b,c] = [1,2,3];

对象的解构：

let {name:myname,sister='have no sister'} = {name : "lisi" ,age :10};

对name重新命名为myname；

sister，设置默认值；对象里面是undefined，才会使用默认值；

### 3.箭头函数

const fn = () =>{}

**箭头函数this的指向：**https://www.cnblogs.com/fanzhanxiang/p/8888963.html

ES6中新增了箭头函数这种语法,箭头函数以其简洁性和方便获取this的特性。下面来总结一下他们之间的区别：

**普通函数下的this:**

- 在普通函数中的thi指向的是函数的调用者，在默认情况下，this指的是window，
- 在严格模式下,没有直接调用者的函数中的this是 undefined
- call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象

**箭头函数中的this:**

-  箭头函数没有自己的this, 它的this是继承父亲而来; 默认指向在**定义它时所处的对象(宿主对象),**不会因为调用方法的改变而改变；
-  而不是执行时的对象, 定义它的时候,可能环境是window,也有可能是其他的。

```javascript
var jelly={
            name:"jelly",
            hobbies : ["吃饭","睡觉","打豆豆"],
            gethobbies:function(){
                // this.hobbies.map(function(hh){
                //     console.log(this.name + hh);
                // })
                //回调函数，单独执行的时候，this指向的是window
                
                this.hobbies.map(hh=>{
                    console.log(this.name + hh);
                })
            }
        }
        jelly.gethobbies();
```

### 4.剩余参数和扩展运算符

#### 4.1 剩余参数（函数里面的）

function sum(n1,...args)

...args：放在一个数组中，然后用forEach循环出来；

const person=["apple","123",100,100,90,80];

const [name,id,...score] = person;

![image-20200202220058499](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20200202220058499.png)

#### 4.2 ...扩展运算符

把可遍历对象扩展放在一个新的数组中；

1.连接数组：const members = [...arr1,'mary',...arr2];

2.把字符串分割成一个个字符："l","o","v","e"



### 5.内置对象扩展

#### 5.1 数组

| 方法               | 用途                                                         | 返回值     |
| ------------------ | ------------------------------------------------------------ | ---------- |
| push(...arr)       | 连接数组                                                     | 新数组     |
| find()             | 查找对象，返回第一个符合条件的对象                           | 返回对象   |
| findIndex()        | 查找对象，返回索引值；没有就是-1                             | Boolean值  |
| includes(2)        | 是否包含某元素，返回true/false；                             | Boolean值  |
| Array.from(类数组) | 类数组转换成真正的数组；然后调用数组的方法；map，reduce这些； | 新数组     |
| Array.of(1,2,3)    | 转换成[1,2,3]                                                | 新数组     |
|                    |                                                              |            |
| forEach            | 循环遍历数组                                                 | 无返回值   |
| reduce             | 求和                                                         | 无         |
| every              | 查找元素，全部找                                             | Boolean值  |
| some               | 查找元素，找到就不找了                                       | Boolean值  |
| filter             | 筛选数组                                                     | 返回新数组 |
| map                | 循环遍历数组，不改变原数组                                   | 返回新数组 |

备注：array.reduce(function(prev, current, currentIndex, arr), initialValue)

#### 5.2 字符串

str.startWith("51"，9)；以什么开头

str.endsWith("11")：以什么结尾

str.includes("12")：包含什么

str.repeat(4)：重复字符串

### 6.模板字符串

```javascript
const person='jelly'
const sentence = `${person} is mouse`
``也可以当做参数传递给函数 getdata`data ${person}`
```

变量可以使用${变量}的方式使用；

### 7.for of 循环

for：太繁琐；

forEach：循环简洁，但是不能中止循环；

for index in fruits：循环的是属性名；缺陷：会把原型链上的都循环出来；

for item of fruits：循环的是属性值，可以中止循环。不会循环非属性值；

应用场景：对数组进行循环；

for(let [index,item] of fruits.entries())

### 8.Promise

1.简介

就是一个承诺，下单了，有个订单号，这个订单是被接单，还是被拒单，都有反馈结果；

axios是基于promise API的，直接.then()，.catch；

```javascript
const p = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve("success")
    },1000)
})
p.then(data=>{ console.log(data) })
 .catch(err=>{ console.log(err) });
```

2.处理多个promise：all，race

```javascript
Promise.all([pro1,pro2])
		.then(res=>{
    const [users,movie] = res;  //对象解构
})
.catch(err=>{ console.log(err) });
```

### 9.Symbol基本数据类型

1.用来创建唯一的标识符；当做属性名；

```javascript
const peter = Symbol(); //生成唯一的标识符，解决对象命名冲突，里面可以写 描述
const class={
    [Symbol('lili')]:{name:'lili',age:10},
    [Symbol('loli')]:{name:'loli',age:20},
    [Symbol('loli')]:{name:'loli',age:210}
}
```

2.给对象添加symbol属性名，要用[]，不能使用.

3.不能使用普通的遍历，for  in也不行；Object.getOwnPropertySymbols(classRoom) 

```js
let classobj = Object.getOwnPropertySymbols(class)
//返回值：就是symbol属性值

let classall = Reflect.ownKeys(obj)
//返回所有的属性值：symobol和常规的
```

### 10.ESLint

airbnb：js代码规范

配置文件：网上找配置；安装插件，选择模式；

运行：eslint bad.js

### 11.class

class：ES6新加的类；就相当于构造函数；

```javascript
class Star{
    constructor(uname){
        this.uname = uname;
    }
    sing(){
        console.log('唱歌');
    }
    static dance(){
        console.log('跳舞');//静态方法，只有Star.dance()，才能调用
    }
    set github(value){
        this.githubName = value;//set方法
    }
    get github(){
        return `http://github.com/${this.githubname}`;//get方法
    }
}
const ldh = new Star('刘德华');
```

继承：extends：儿子继承父亲

super：访问和调用父类上的函数；可以调用构造函数，也可以调用普通函数；

```javascript
class Father{
    constructor(x,y){
        this.x = x;
        this.y = y;
    }
    sum(){
        console.log(this.x + this.y);
    }
}
class Son extends Father{
    constructor(x,y){
        super(x,y); //调用父类的构造函数，相当于Father.call(this,x,y)
        this.x = x;
        this.y = y;
        super.sum(x,y);//调用父类的普通函数
    }
    super.say();
}
```

类里面的this指向：

constructor：指向创建的实例对象：ldh

方法：调用者；

### 12.模块

导出：

export default（可以自己命名，只能默认导出一个default）

export 多个变量（按照文件里的变量命名）

```javascript
//任意导出
const apikey = '123';
export default apikey;//默认导出
import apikeykey from './apikey.js'   //这里可以使用任意名字

//命名导出
export const apikey = '123';
export const url = 'www.hao.com';
import { apikey,url } from './123.js'   //使用指定的名字导出
```

babel插件：将ES6转换成ES5；浏览器不兼容ES6；

babel-polyfill，有的新属性方法，识别不来的；

### 13.遍历器Iterator

```js
它提供了一种统一的遍历数据的方法;只要数据结构，部署了symbol.iterator属性，那么就可以使用for  of进行遍历，使用next()方法进行遍历；返回值：{value，done}

数组：
colors=['red','blue','yellow']
const i = colors.entries()
i.next()   //value: Array(2), done: false

const v = colors.value()
v.next()   //value: "red", done: false
```

运用到的场合：

解构赋值，扩展运算符，yield\*，for of，Array.from，set，map



### 14.生成器generator

```js
function* helloworld(){
    yield 11+10;
    yield 'world';
    return 'ending';
}

let hw = helloworld();  //返回的是遍历器对象（Iterator Object）
console.log(hw.next());
console.log(hw.next());
```

generator函数就是iterator接口生成函数；所以需要调用next()方法，进行执行；



2.next参数：该参数就会被当作上一个`yield`表达式的返回值。













### 15.Set：新数据结构，类似于数组

Set与Array：没有索引值；数组去重；元素是唯一的；

```javascript
const colors = new Set();
1.方法：
[...colors]
colors.add('red');
colors.add(5);
colors.size;
colors.delete(5);
colors.has(5);


2.数组、字符串去重
[...new Set([11,12,11,13])]   //使用扩展运算符

const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);  //转换成数组


3.4种遍历方法
keys()，values()，entries()，forEach()
for(let i of set.keys()){
     console.log(i)
}
set：键和值都是一样的；遍历器默认是values
```

weakSet：成员只能是对象；对象是弱引用（没有被引用的话，就会垃圾自动回收机制）

```js
方法：add，has，delete
new weakSet([{name:'123',age:19},{name:'11',age:90}])

不能进行遍历，因为是弱引用机制，不知道啥时候会被回收；
```

### 16.Map：新数据结构，类似于对象

存储的是键值对，相当于对象；键值可以是任意类型的数据；

![image-20200223202417265](C:\Users\chen\AppData\Roaming\Typora\typora-user-images\image-20200223202417265.png)

```javascript
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

1.方法
set,get,has,delete,clear,size
m.set({name:00},'123')

2.遍历
keys()，values()，entries()，forEach()

3.转换成数组:[...map]
```

weakMap：只接受对象作为键值名（除了null），键名弱引用；

应用：DOM 节点作为键名；如果删除了，就会被销毁，不存在内存泄漏问题；

### 17.await和async

使用这两个关键字，可以像同步执行一样，执行异步代码；



